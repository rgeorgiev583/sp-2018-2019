# Изпълнение на команди

Употреба на функции от семейството на `exec(3)`.

## `exec(3)`

(Самото системно извикване се казва `execve(2)`, като за него са предоставени няколко библиотечни функции, описани под името `exec(3)` в документацията.)

Това системно извикване се използва за стартиране на изпълним файл вместо текущия процес (т.е. без да се създава нов процес).

    #include <unistd.h>

    int execl(const char* path, const char* arg, ..., NULL);
    int execlp(const char* cmd, const char* arg, ..., NULL);
    int execv(const char* path, char* const argv[]);
    int execvp(const char* cmd, char* const argv[]);

Всяка от дадените по-горе функции извършва едно и също нещо (замества изображението на текущия процес с подадената като аргумент команда), като просто приема различни аргументи:

* `execl` изпълнява програмата, намираща се във файла с точен път `path`.  Пътят трябва да е абсолютен (например `/bin/sh`).  `execl` подава аргументите на функцията, започващи от втория, като командни аргументи (*command-line arguments*) на изпълнимия файл.  Списъкът с аргументи трябва задължително да завършва с нулев указател (*NULL*), който отбелязва неговия край и не се включва към самите командни аргументи.

* `execlp` изпълнява командата с име `cmd`.  Ако `cmd` започва със `/` (абсолютен път), функцията се държи като `execl`.  В противен случай тя търси изпълним файл с име `cmd` последователно във всички директории, посочени в променливата на средата `PATH`, докато не го намери.  Стойността на тази променлива изглежда по подобен начин (обикновено на различните системи записите са различни), като пътищата към директориите за обхождане се разделят със знака `:`:

        $ echo $PATH
        /usr/local/sbin:/usr/local/bin:/usr/bin

    При намирането на подходящ файл функцията го изпълнява по същия начин като `execl`.

* `execv` изпълнява програмата, намираща се във файла с точен път `path` (аналогично на `execl`).  Тя подава аргументите на функцията, намиращи се в подадения като втори аргумент масив от низове, като командни аргументи (*command-line arguments*) на изпълнимия файл.  Последният елемент на масива трябва задължително да завършва с нулев указател (*NULL*), който отбелязва неговия край и не се включва към самите командни аргументи.

* `execvp` изпълнява командата с име `cmd` (аналогично на `execlp`).  Командните параметри се подават по същия начин, както при `execv`.

Не забравяйте, че по подразбиране първият команден аргумент винаги е името на командата или на изпълнимия файл.  (Това не е задължително да се спази, за да се изпълни успешно командата, но е добра практика.)

При успешно изпълнение нито една от горните функции не връща резултат.  При провал на която и да е от тях тя връща стойност `-1`.

## Задачи

1. Напишете програма на C, която приема последователност от имена на файлове `FILE...` като аргументи и изпълнява командния ред `cat FILE...`.

2. Напишете програма `execute` на C, която изпълнява командния ред, подаден като аргументи на командния ред.

    **Пример**: Извикването на `./execute cat foo bar baz` трябва да изпълни командата `cat foo bar baz`.

3. Напишете програма на C, която изпълнява всяка една от командите, подадени като аргументи на командния ред.

4. Напишете програма на C, която изпълнява командата `wc` по различен начин в зависимост от подадените аргументи:

   * ако аргументите са `chars FILE...`, то да се изпълни `wc -c FILE...`;
   * ако аргументите са `words FILE...`, то да се изпълни `wc -w FILE...`;
   * ако аргументите са `lines FILE...`, то да се изпълни `wc -l FILE...`.

5. Напишете програма `trf` на C, която се извиква по следния начин: `trf SET1 SET2 FILE DEST`.  Програмата трябва да изпълнява командния ред `tr SET1 SET2` по такъв начин, че командата `tr` да чете от файла `FILE` и да пише във файла `DEST`.

6. Напишете програма на C, която приема аргумент `FILE` и изпълнява командния ред `wc FILE`, но без да извежда името на файла `FILE`.