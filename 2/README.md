# Работа с файлове
(записки към второто упражнение)

Употреба на системните извиквания `open(2)`, `create(2)`, `read(2)`, `write(2)` и `close(2)`.

## `open(2)`

    #include <fcntl.h>

    int open(const char* pathname, int flags);
    int open(const char* pathname, int flags, mode_t mode);

Системното извикване `open()` отваря файла, определен от подадения като аргумент `път`.  Ако този файл не съществува, той ще бъде създаден от `open()`, ако флагът `O_CREAT` бъде зададен в аргумента `флагове` на `open()`.

При успешно отваряне на файла `open()` връща файлов дескриптор, сочещ към отворения файл.  Файловият дескриптор представлява малко неотрицателно число, което се използва в последващи извиквания на другите системни извиквания за работа с файлове (т.е. `read(2)`, `write(2)`, `close(2)` и т.н.), за да определи върху кой отворен файл да се извърши съответната операция.  Дескрипторът, върнат при успешно извикване на `open()`, е винаги най-малкото такова число, което все още не е асоциирано с отворен файл за текущия процес.

По подразбиране файловият дескриптор остава отворен при извикване на `exec(3)` (т.е. флагът `FD_CLOEXEC` по подразбиране е изключен); флагът `O_CLOEXEC` (описан по-долу) може да се използва с цел затваряне на дескриптора при `exec(3)`.  Позицията за четене или писане първоначално е зададена да е в началото на файла (виж `lseek(2)`).

При извикване на `open()` се създава *дескрипция (инстанция)* на отворен файл, която се добавя в системния списък с отворени файлове.  В тази дескрипция се намира текущата позицията за четене или писане във файла, както и флаговете, зададени в аргумента `flags`.  Файловият дескриптор играе ролята на указател към дескрипцията.

Аргументът `flags` **трябва** да включва един от следните флагове за *режим на достъп*: `O_RDONLY` (достъп до файла само за четене), `O_WRONLY` (достъп до файла само за писане) или `O_RDWR` (достъп до файла както за четене, така и за писане).

Освен това във `flags` може да се зададат някои допълнителни флагове, комбинирани чрез оператора `|` (побитова дизюнкция) с флага за режим на достъп:
* флагове, свързани с отварянето на файла: `O_CLOEXEC`, `O_CREAT`, `O_EXCL` и `O_TRUNC`;
* флагове, свързани със състоянието на отворения файл: `O_APPEND`.

Допълнителните флагове имат следната семантика:

* `O_APPEND`: ако файлът е отворен в режим за писане, всяка операция за писане да се извършва в края на файла.  Това означава, че позицията за четене и писане директно се премества в края на файла (все едно е изпълнено `lseek(2)` с втори аргумент `0` и трети аргумент `SEEK_END`) преди всеки `write(2)`.  Разликата с `open(2)` без `O_APPEND` е, че промяната на позицията за писане и самото писане се извършват като единична атомарна операция.

* `O_CLOEXEC`: файловият дескриптор, асоцииран с отворения файл, да се затвори при извикване на `exec(3)`.

* `O_CREAT`: ако файл с път `pathname` към него не съществува, той да бъде създаден с разрешения (т.е. *режим* на файла), зададени посредством аргумента `mode`.  Наличието на `O_CREAT` означава, че аргументът `mode` е задължителен.

    За да се зададе режимът на файла, може да се използват следните символни константи:

    * `S_IRWXU` == `00700`: потребителят (собственикът на файла) има разрешения за четене, писане и изпълнение на файла;
    * `S_IRUSR` == `00400`: потребителят има разрешение за четене от файла;
    * `S_IWUSR` == `00200`: потребителят има разрешение за писане във файла;
    * `S_IXUSR` == `00100`: потребителят има разрешение за изпълнение на файла;
    * `S_IRWXG` == `00070`: потребителите от групата, към която принадлежи потребителят, имат разрешения за четене, писане и изпълнение на файла;
    * `S_IRGRP` == `00040`: групата има разрешение за четене от файла;
    * `S_IWGRP` == `00020`: групата има разрешение за писане във файла;
    * `S_IXGRP` == `00010`: групата има разрешение за изпълнение на файла;
    * `S_IRWXO` == `00007`: всички останали потребители имат разрешения за четене, писане и изпълнение на файла;
    * `S_IROTH` == `00004`: всички останали имат разрешение за четене от файла;
    * `S_IWOTH` == `00002`: всички останали имат разрешение за писане във файла;
    * `S_IXOTH` == `00001`: всички останали имат разрешение за изпълнение на файла;
    * `S_ISUID` == `0004000`: *set-user-ID* (`setuid`) бит;
    * `S_ISGID` == `0002000`: *set-group-ID* бит;
    * `S_ISVTX` == `0001000`: *sticky* бит.

* `O_EXCL`: ако файл с път `pathname` към него вече съществува, `open()` да върне грешка.  Този флаг винаги се използва заедно с `O_CREAT`.

* `O_TRUNC`: ако файлът с път `pathname` към него вече съществува и файлът е отворен в режим на писане, цялото му съдържание да бъде изтрито (т.е. размерът му да се сведе до `0`).

При грешка `open()` връща стойност `-1` и номерът на грешката се задава в `errno`.

## `creat(2)`

    int creat(const char *pathname, mode_t mode);

Извикването на `creat()` е еквивалентно на извикване на `open()` със стойност `O_CREAT|O_WRONLY|O_TRUNC` на аргумента `flags`.

## `read(2)`

    #include <unistd.h>

    ssize_t read(int fd, void* buffer, size_t count); 

Системното извикване `read()` се опитва да прочете `count` на брой байта от файла, указан чрез файловия дескриптор `fd`, в буфера `buffer`.  Операцията започва от текущата позиция за четене и писане във файла, като тя се увеличава с броя на успешно прочетените байтове.  Ако позицията сочи към края на файла или след него (виж `lseek(2)`), не се прочита нищо и `read()` връща `0`.

При успех се връща броят на прочетените байтове (ако са `0`, значи сме достигнали края на файла).  Не е грешка, ако този брой е по-малък от указания в аргумента `count`: това може да се случи например ако размерът на файла е по-малък от `count` или ако във файла има по-малко от `count` на брой оставащи байтове спрямо текущата позиция за четене и писане.  При грешка `read()` връща стойност `-1` и номерът на грешката се задава в `errno`.

## `write(2)`

    #include <unistd.h>

    ssize_t write(int fd, const void* buffer, size_t count); 

Системното извикване `write()` се опитва да запише `count` на брой байта от буфера `buffer` във файла, указан чрез файловия дескриптор `fd`.  Операцията започва от текущата позиция за четене и писане във файла, като тя се увеличава с броя на успешно записаните байтове.

При успех се връща броят на записаните байтове.  Не е грешка, ако този брой е `0` или е по-малък от указания в аргумента `count`: това може да се случи например ако няма достатъчно място на устройството, върху което пишем.  При грешка `write()` връща стойност `-1` и номерът на грешката се задава в `errno`.

## `close(2)`

    #include <unistd.h>

    int close(int fd);

Системното извикване `close()` затваря файловия дескриптор `fd` и премахва асоциацията със съотетстващата му дескрипция, така че той да може да бъде преизползван при последващо извикване на `open(2)`.  Ако `fd` е единственият файлов дескриптор, който сочи към тази дескрипция (виж `open(2)`), ресурсите, асоциирани с нея, се освобождават.

При успешно затвяране на файла `close()` връща стойност `0`, а при грешка връща стойност `-1` и номерът на грешката се задава в `errno`.

## Задачи

Да се напише програма на C, която реализира командата:

1. `cat` (*без параметри*)
2. `tee ФАЙЛ` (подаваме `ФАЙЛ` като аргумент на програмата)
3. `cat >> ФАЙЛ` (подаваме `ФАЙЛ` като аргумент на програмата)
4. `head -cN ФАЙЛ`, където `N` е броят символи, които да се изведат от началото на файла (подаваме `N` и `ФАЙЛ` като аргументи на програмата)
5. `tail -c+N ФАЙЛ`, където `N` е броят символи от началото на файла, които да се пропуснат, преди да се изведе останалата част от файла (подаваме `N` и `ФАЙЛ` като аргументи на програмата)
6. `cat ФАЙЛ...` (идеята е да се разшири имплементацията на първата задача, така че да могат да ѝ се подават неограничен брой имена на файлове като аргументи)