# Създаване и управление на процеси

Употреба на системните извиквания `fork(2)`, `wait(2)`, `waitpid(2)`, `exit(3)`.

## `fork(2)`

    #include <unistd.h>

    pid_t fork(void);

Системното извикване `fork()` създава нов процес чрез създаване на копие на процеса, който го е извикал.  Новият процес се нарича процес-дете, а старият - процес-родител.
При `fork()` се копира всичко от паметта, свързана с процеса: изображението му (т.е. програмата, която се изпълнява), стекът с извикванията, хийпът на процеса, както и файловите дескриптори и текущия контекст на процеса.  Родителят и детето са напълно независими един от друг и сегментите им в паметта са напълно отделни.
При успех `fork()` връща номера (*PID*) на новосъздадения процес в процеса-родител.  В процеса-дете `fork()` връща 0.  При провал на операцията върнатата стойност е `-1`.

## `wait(2)`

    #include <sys/wait.h>

    pid_t wait(int* status);

Системното извикване `wait()` изчаква приключването на който и да е процес от децата на текущия процес, т.е. тя блокира изпълнението на програмата, докато той не завърши.  В аргумента `status` се подава указател към целочислена променлива, в която се запазва върнатият изходен код от процеса-дете (който всъщност е аргументът, подаден на `exit` в процеса-дете, или върнатата стойност в неговата `main` функция), както и друга информация, свързана с приключването на процеса.  `status` не може да бъде `NULL`, дори да не се ползва от процеса-родител впоследствие.
При успех `wait()` връща PID-а на приключилия процес, а при провал връща `-1`.
За да се провери дали процесът е приключил успешно, може да се използва макросът `WEXITSTATUS`, който приема като аргумент стойността на променливата `status` и връща кода на завършване на процеса.  Друг полезен макрос е `WIFEXITED`, който приема като аргумент стойността на `status` и връща дали процесът е приключил по нормален начин (т.е. чрез извикване на `exit(3)`).

## `waitpid(2)`

    #include <sys/wait.h>

    pid_t waitpid(pid_t pid, int* status, int options);

Системното извикване `waitpid()` изчаква приключването процеса с посочения в аргумента `pid` процесен идентификатор.  Той трябва да е дете на текущия процес.  Аргументът `status` се ползва по същия начин, както в `wait`, а в `options` се подават специални флагове (по подразбиране се подава стойност `0`).
При успех `waitpid()` връща PID-а на приключилия процес, а при провал връща `-1`.

## `exit(3)`

    #include <stdlib.h>

    void exit(int status);

Функцията `exit()` се използва за приключване на изпълнението на процес с подадения в аргумента `status` изходен код (който се използва от `wait` и `waitpid`, вж. горе).  Вътрешно тя извиква системния примитив `_exit(2)`.

## Задачи

1. Напишете програма на C, която поражда нов процес, който директно приключва без грешки, и извежда номера му и кода му на завършване.

2. Напишете програма на C, която получава като параметри на командния ред име на команда и списък с аргументи, изпълнява командата и извежда кода ѝ на завършване.

3. Напишете програма на C, която получава като параметри на командния ред две имена на команди (`CMD1` и `CMD2`) и реализира конструкцията `CMD1 && CMD2`.

4. Напишете програма на C, която получава като параметри на командния ред две имена на команди (`CMD1` и `CMD2`) и реализира конструкцията `CMD1 || CMD2`.

5. Имплементирайте програмата от задача 3. по такъв начин, че да работи с неограничен брой команди.

6. Имплементирайте програмата от задача 4. по такъв начин, че да работи с неограничен брой команди.
